#!/usr/bin/env python3
#
# DOWNLOAD DATA FROM OPEN-ADAS
#
# This script downloads atomic ionization/recombination and radiation data from
# the Open-ADAS database (https://open.adas.ac.uk/).
#

import argparse
import datetime
import json
import numpy as np
import os
import pathlib
import sys
import ADAS


def compile_elements(elements, outputfile=None, inttype='len_t', realtype='real_t'):
    """
    Generate a C++ file containing the given ADAS data.
    """
    ds = ""
    ss = "const {0} adas_rate_n = {1};\nstruct adas_rate adas_rate_table[{1}] = {{\n".format(inttype, len(elements))
    sd = None

    # Write data
    for elname, ratedata in elements.items():
        Z = ratedata['Z']

        if sd is not None: sd += "},\n"
        else: sd = ""

        sd += "\t{{\"{0}\",{0}_Z".format(elname)

        ds += "/* {} */\n".format(elname)
        ds += "const {0} {1}_Z = {2};\n".format(inttype, elname, Z)

        # acd, scd, plt, prb
        for dt, data in ratedata.items():
            if dt == 'Z': continue

            nn = len(data['n'])
            nT = len(data['T'])

            ds += "const {0} {1}_{2}_nn = {3};\nconst {0} {1}_{2}_nT = {4};\n".format(inttype, elname, dt, nn, nT)

            ds += "const {0} {1}_{2}_n[{3}] = {{".format(realtype, elname, dt, nn)
            ds += ','.join(['{:.5f}'.format(x) for x in data['n']])
            ds += "};\n"

            ds += "const {0} {1}_{2}_T[{3}] = {{".format(realtype, elname, dt, nT)
            ds += ','.join(['{:.5f}'.format(x) for x in data['T']])
            ds += "};\n"

            ds += "const {0} {1}_{2}_coeff[{3}] = {{".format(realtype, elname, dt, Z*nn*nT)
            ds += ','.join(['{:.5f}'.format(x) for x in data['data'].flatten()])
            ds += "};\n\n"

            sd += ",{0}_{1}_nn,{0}_{1}_nT,{0}_{1}_n,{0}_{1}_T,{0}_{1}_coeff".format(elname, dt)

    sd += "}\n};\n"

    filecontents  = "/* This file was auto-generated by 'get_adas.py' on {} */\n\n".format(datetime.datetime.now().isoformat(sep=' ', timespec='seconds'))
    filecontents += "#include \"DREAM/adasdata.h\"\n\n"
    filecontents += ds + ss + sd

    if outputfile is not None:
        # Create directory if it doesn't already exists
        pathlib.Path(outputfile).parent.mkdir(parents=True, exist_ok=True)

        # Write C++ file
        with open(outputfile, 'w') as f:
            f.write(filecontents)

    return filecontents


def main(argv):
    path = pathlib.Path(__file__).parent.absolute()
    elementsfile = '{}/elements.json'.format(path)
    outputfile = os.path.abspath('{}/../src/Atomics/adasdata.cpp'.format(path))
    cachedir = '{}/cache'.format(path)

    parser = argparse.ArgumentParser(description="Download and compile rate coefficients from Open-ADAS.")
    parser.add_argument('--cachedir', dest='cachedir', action='store', default=cachedir, type=str, help="Path to directory in which to store/load cached data files to/from.")
    parser.add_argument('--elements', dest='elementsfile', action='store', default=elementsfile, type=str, help="Name of file containing ADAS element specifications.")
    parser.add_argument('--no-cache', dest='cache', action='store_false', help="Forces data to be downloaded from Open-ADAS and prevents Open-ADAS files from being stored locally.")
    parser.add_argument('--no-compile', dest='compile', action='store_false', help="Do not generate C++ source files with the rate coefficients.")
    parser.add_argument('-o', '--output', dest='output', action='store', default=outputfile, help="Name of output C++ source file to generate.")
    parser.add_argument('--type-int', dest='inttype', action='store', default='len_t', help="C++ type to use for integers.")
    parser.add_argument('--type-real', dest='realtype', action='store', default='real_t', help="C++ type to use for real numbers.")

    args = parser.parse_args()

    ADAS_ELEMENT_LIST = ADAS.data.load_element_list(args.elementsfile)

    ELEMENTS = {}
    for element, year in ADAS_ELEMENT_LIST.items():
        ELEMENTS[element] = ADAS.data.load_element(element, year, cache=args.cache, cachedir=args.cachedir)

    # Compile 
    if not args.compile:
        return 0

    compile_elements(ELEMENTS, outputfile=args.output, inttype=args.inttype, realtype=args.realtype)
        

if __name__ == '__main__':
    sys.exit(main(sys.argv[1:]))

